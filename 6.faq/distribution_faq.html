

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Distributed System FAQ &mdash; Java handbook 1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=e536ea0c" />
      <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=29a6c3e3"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
      <script src="../_static/design-tabs.js?v=f930bc37"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="spring boot faq" href="spring_boot_faq.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Java handbook
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1.basic/index.html">1. Basic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2.library/index.html">2. Framework and Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3.middleware/index.html">3. Middleware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../4.architecture/index.html">4. Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../5.tips/index.html">5. Tips</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">6. FAQ</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="j2se_faq.html">Java FAQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="mybatis_faq.html">MyBatic FAQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="mysql_faq.html">MySQL FAQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="quarkus_faq.html">Quarkus FAQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="spring_faq.html">Spring FAQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="spring_boot_faq.html">spring boot faq</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Distributed System FAQ</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cap">CAP 原理是什么?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">分布式事务怎么实现？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">分布式事务与 CAP 的关系：</a></li>
<li class="toctree-l3"><a class="reference internal" href="#raft">分布式协议 RAFT 是怎么实现一致性的?</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">RAFT 协议的核心目标</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">RAFT 协议的核心角色</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">RAFT 的三个核心子模块</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id8">RAFT 如何实现一致性</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">RAFT 的优点</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">RAFT 的缺点</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">总结</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#paxos">分布式协议 Paxos 是怎么实现一致性的?</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id12">Paxos 协议</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id13">Paxos 的基本概念</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id14">Paxos 的主要流程</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id15">Paxos 的一致性保障</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id16">Paxos 的优点</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id17">Paxos 的缺点</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id18">Paxos 的改进版本</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id19">总结</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Java handbook</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">6. FAQ</a></li>
      <li class="breadcrumb-item active">Distributed System FAQ</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/6.faq/distribution_faq.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="distributed-system-faq">
<h1>Distributed System FAQ<a class="headerlink" href="#distributed-system-faq" title="Link to this heading"></a></h1>
<section id="cap">
<h2>CAP 原理是什么?<a class="headerlink" href="#cap" title="Link to this heading"></a></h2>
<p>CAP 原理（CAP Theorem）是分布式系统中一个著名的理论，由 Eric Brewer 在 2000 年提出。它描述了分布式系统在一致性、可用性和分区容错性三者之间的权衡关系。</p>
<p>三个核心概念：</p>
<ol class="arabic simple">
<li><p>一致性（Consistency）
所有节点在同一时间看到的数据是一致的，即系统对某一操作的所有副本更新成功后才会返回结果。
例子：银行账户余额的操作，任何时候查询都必须反映最新的交易记录。</p></li>
<li><p>可用性（Availability）
系统始终能够响应用户的读写请求，即使某些节点失效。换句话说，服务必须是可用的，但返回的结果可能不一定是最新的。
例子：购物网站在促销高峰时，某些延迟的数据更新不会影响其提供基本购物功能。</p></li>
<li><p>分区容错性（Partition Tolerance）</p></li>
</ol>
<p>系统在面对分区（网络故障、节点故障）时，仍然能够继续工作。
例子：两个数据中心之间的网络断开后，各自的数据副本仍能正常提供服务。</p>
<p>核心理论：</p>
<p>在一个分布式系统中，不可能同时完全满足一致性、可用性和分区容错性，只能三者中满足两个：</p>
<ul class="simple">
<li><p>CP 系统：放弃可用性，保证一致性和分区容错性。
例子：分布式数据库如 HBase。</p></li>
<li><p>AP 系统：放弃一致性，保证可用性和分区容错性。
例子：DNS 系统。</p></li>
<li><p>CA 系统：放弃分区容错性，保证一致性和可用性（理论上无法实现，因为分区容错性对分布式系统至关重要）。</p></li>
</ul>
<p>CAP 原理强调了分布式系统设计中的权衡，需要根据应用场景选择最合适的折中方案。</p>
</section>
<section id="id1">
<h2>分布式事务怎么实现？<a class="headerlink" href="#id1" title="Link to this heading"></a></h2>
<p>分布式事务是指跨多个服务或数据库的事务操作，这些操作需要满足原子性、一致性、隔离性和持久性（ACID）原则。分布式事务在分布式系统中较为复杂，因为它涉及多个节点之间的协调和同步。</p>
<p>常见的分布式事务实现方式：</p>
<ol class="arabic simple">
<li><p>两阶段提交（2PC, Two-Phase Commit）</p></li>
</ol>
<ul class="simple">
<li><p>阶段 1：准备阶段（Prepare Phase）
所有参与者节点执行事务并将更改写入日志，但不提交。协调者节点等待所有参与者的响应。</p></li>
<li><p>阶段 2：提交阶段（Commit Phase）
如果所有参与者都准备成功，则协调者发出提交命令；否则，发出回滚命令。</p></li>
</ul>
<p>优点：实现简单，适用于需要强一致性的场景。
缺点：存在性能瓶颈，且在协调者失效时可能导致阻塞问题。</p>
<ol class="arabic simple" start="2">
<li><p>三阶段提交（3PC, Three-Phase Commit）</p></li>
</ol>
<ul class="simple">
<li><p>引入了一个预提交阶段，进一步减少阻塞风险。</p></li>
<li><p>分为：CanCommit、PreCommit 和 Commit。</p></li>
<li><p>优点：相比 2PC，更容错，但仍不能完全避免脑裂问题。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>基于消息队列的事务</p></li>
</ol>
<ul class="simple">
<li><p>思路：通过可靠消息队列协调事务的一致性。</p></li>
<li><p>举例：订单创建与支付状态更新通过消息队列进行异步协调。</p></li>
<li><p>优点：适用于最终一致性场景，性能较高。</p></li>
<li><p>缺点：需要仔细设计补偿逻辑。</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>TCC 模型（Try-Confirm-Cancel）</p></li>
</ol>
<ul class="simple">
<li><p>将事务分为三个步骤：</p>
<ul>
<li><p>Try：预留资源。</p></li>
<li><p>Confirm：确认并提交操作。</p></li>
<li><p>Cancel：回滚并释放资源。</p></li>
</ul>
</li>
<li><p>适用场景：电商、金融等需要资源预留的分布式场景。</p></li>
<li><p>优点：高灵活性，可控制粒度。</p></li>
<li><p>缺点：业务逻辑复杂，开发成本较高。</p></li>
</ul>
<ol class="arabic simple" start="5">
<li><p>Saga 模式</p></li>
</ol>
<ul class="simple">
<li><p>将长事务拆分为一系列短事务，每个短事务都有对应的补偿操作。</p></li>
<li><p>两种协调方式：</p>
<ul>
<li><p>顺序协调：一个事务失败，立即触发补偿。</p></li>
<li><p>事件驱动协调：通过事件总线协调事务。</p></li>
</ul>
</li>
<li><p>优点：性能较高，适合最终一致性场景。</p></li>
<li><p>缺点：事务复杂性高，依赖补偿操作的正确性。</p></li>
</ul>
</section>
<section id="id2">
<h2>分布式事务与 CAP 的关系：<a class="headerlink" href="#id2" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p>分布式事务通常会选择一致性（C）和分区容错性（P），在可用性（A）上进行妥协。</p></li>
<li><p>在很多实际场景中，分布式系统更倾向于最终一致性（如 Saga 和消息队列），从而提高系统可用性。</p></li>
</ul>
</section>
<section id="raft">
<h2>分布式协议 RAFT 是怎么实现一致性的?<a class="headerlink" href="#raft" title="Link to this heading"></a></h2>
<p>RAFT 是一种用于分布式系统中实现一致性的协议，它提供了更易理解的方式来实现分布式日志复制。RAFT 协议特别适用于一致性和分区容错性（CP）系统，主要用于构建分布式存储系统（如 etcd 和 Consul）。以下是 RAFT 的详细工作原理及实现一致性的方式：</p>
<section id="id3">
<h3>RAFT 协议的核心目标<a class="headerlink" href="#id3" title="Link to this heading"></a></h3>
<p>RAFT 的主要目标是确保分布式系统中：</p>
<ol class="arabic simple">
<li><p>所有节点共享一个一致的日志。</p></li>
<li><p>系统能够在部分节点故障时继续工作。</p></li>
<li><p>系统能够处理网络分区问题。</p></li>
</ol>
</section>
<section id="id4">
<h3>RAFT 协议的核心角色<a class="headerlink" href="#id4" title="Link to this heading"></a></h3>
<p>RAFT 集群由多个节点组成，每个节点可以扮演以下三种角色之一：</p>
<ol class="arabic simple">
<li><p>Leader（领导者）：</p></li>
</ol>
<ul class="simple">
<li><p>负责处理所有客户端请求。</p></li>
<li><p>负责日志的复制和提交。</p></li>
<li><p>每个任期（term）最多只能有一个 Leader。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>Follower（追随者）：</p></li>
</ol>
<ul class="simple">
<li><p>被动响应来自 Leader 的指令。</p></li>
<li><p>如果没有收到 Leader 的心跳消息，会发起选举。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>Candidate（候选者）：</p></li>
</ol>
<ul class="simple">
<li><p>由 Follower 转变而来，在选举期间竞选成为 Leader。</p></li>
</ul>
</section>
<section id="id5">
<h3>RAFT 的三个核心子模块<a class="headerlink" href="#id5" title="Link to this heading"></a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1. Leader 选举
2. 日志复制
3. 日志一致性保障
</pre></div>
</div>
<section id="leader">
<h4>1. Leader 选举<a class="headerlink" href="#leader" title="Link to this heading"></a></h4>
<p>在分布式系统中，需要选出一个 Leader 来协调各节点操作。RAFT 使用如下步骤实现 Leader 选举：</p>
<ol class="arabic simple">
<li><p>初始状态：</p></li>
</ol>
<ul class="simple">
<li><p>所有节点默认为 Follower。</p></li>
<li><p>如果 Follower 在选举超时时间内没有收到 Leader 的心跳消息，则转为 Candidate 并发起选举。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>选举流程：</p></li>
</ol>
<ul class="simple">
<li><p>Candidate 增加自己的任期号（term）并给自己投票。</p></li>
<li><p>向其他节点发送 RequestVote 请求。</p></li>
<li><p>其他节点对比任期号并决定是否投票：</p></li>
<li><p>如果 Candidate 的任期号比自己高，投票给 Candidate。</p></li>
<li><p>如果任期号较低，则拒绝投票。</p></li>
<li><p>如果 Candidate 获得多数投票（n/2 + 1），成为 Leader。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>选举结果：</p></li>
</ol>
<ul class="simple">
<li><p>如果某个节点成功当选为 Leader，则它开始发送心跳消息，告知其他节点自己是新的 Leader。</p></li>
<li><p>如果选举失败（没有节点获得多数投票），节点会增加任期号并重新开始选举。</p></li>
</ul>
</section>
<section id="id6">
<h4>2. 日志复制<a class="headerlink" href="#id6" title="Link to this heading"></a></h4>
<p>Leader 负责接收客户端请求并将其添加到日志中，然后通过以下过程将日志复制到 Follower：</p>
<ol class="arabic simple">
<li><p>Leader 接收日志条目：</p></li>
</ol>
<ul class="simple">
<li><p>Leader 将客户端的写请求作为新的日志条目添加到其本地日志中，但未立即提交。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>发送 AppendEntries：</p></li>
</ol>
<ul class="simple">
<li><p>Leader 将新的日志条目通过 AppendEntries RPC 发送给所有 Follower。</p></li>
<li><p>消息中包含：</p></li>
<li><p>当前任期号（term）。</p></li>
<li><p>新的日志条目。</p></li>
<li><p>前一个日志条目的索引和任期号（用于一致性检查）。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>Follower 响应：</p></li>
</ol>
<ul class="simple">
<li><p>Follower 检查日志是否连续：</p></li>
<li><p>如果连续，则将日志条目追加到其本地日志中并回复成功。</p></li>
<li><p>如果不连续，则返回失败，Leader 会回退并重新发送正确的日志。</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>提交日志（Log Commit）：</p></li>
</ol>
<ul class="simple">
<li><p>Leader 在收到多数节点确认日志已复制后，将日志条目标记为已提交，并通知所有 Follower 提交日志。</p></li>
<li><p>日志提交后，日志中的操作会生效，响应客户端请求。</p></li>
</ul>
</section>
<section id="id7">
<h4>3. 日志一致性保障<a class="headerlink" href="#id7" title="Link to this heading"></a></h4>
<p>RAFT 通过以下规则保障日志一致性：</p>
<ol class="arabic simple">
<li><p>日志连续性检查：</p></li>
</ol>
<ul class="simple">
<li><p>AppendEntries 消息中包含前一个日志条目的索引和任期号。如果 Follower 的日志不匹配，Leader 会回退日志直到找到匹配点。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>多数派规则：</p></li>
</ol>
<ul class="simple">
<li><p>只有当日志条目被复制到多数节点时，才能认为该条目是已提交的。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>Leader 的日志总是最新的：</p></li>
</ol>
<ul class="simple">
<li><p>在 Leader 选举期间，候选者必须拥有最新的日志，否则无法当选为 Leader。</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>幂等性：</p></li>
</ol>
<ul class="simple">
<li><p>即使日志条目被重复发送，RAFT 保证每个条目在节点上只应用一次。</p></li>
</ul>
</section>
</section>
<section id="id8">
<h3>RAFT 如何实现一致性<a class="headerlink" href="#id8" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p>通过 Leader 提供中心化管理：</p></li>
</ol>
<ul class="simple">
<li><p>所有写操作必须经过 Leader，避免写冲突。</p></li>
<li><p>Leader 确保日志在复制到多数节点后才提交。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>日志的严格顺序：</p></li>
</ol>
<ul class="simple">
<li><p>每个日志条目包含唯一的索引和任期号。</p></li>
<li><p>Follower 的日志与 Leader 保持严格一致。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>容错机制：</p></li>
</ol>
<ul class="simple">
<li><p>即使部分节点宕机，Leader 仍能协调剩余节点完成日志复制。</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>强一致性：</p></li>
</ol>
<ul class="simple">
<li><p>当客户端收到确认时，保证该操作已被提交到多数节点并应用。</p></li>
</ul>
</section>
<section id="id9">
<h3>RAFT 的优点<a class="headerlink" href="#id9" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p>易于理解：相比于 Paxos，RAFT 的逻辑更清晰，更适合工程实现。</p></li>
<li><p>可维护性强：通过划分子问题（选举、日志复制、一致性检查）降低了复杂性。</p></li>
<li><p>容错能力高：允许部分节点失败而不影响整体一致性。</p></li>
</ol>
</section>
<section id="id10">
<h3>RAFT 的缺点<a class="headerlink" href="#id10" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p>性能开销：由于日志复制需要多数节点确认，性能可能低于弱一致性系统。</p></li>
<li><p>网络分区时的延迟：在网络分区严重时，选举和日志同步可能会变慢。</p></li>
</ol>
</section>
<section id="id11">
<h3>总结<a class="headerlink" href="#id11" title="Link to this heading"></a></h3>
<p>RAFT 通过 Leader 选举、日志复制和一致性检查三大机制，实现了分布式系统中的强一致性。
它的设计目标是简化 Paxos 的复杂性，同时提供工程上易实现的解决方案，是构建一致性系统的基础协议之一。</p>
</section>
</section>
<section id="paxos">
<h2>分布式协议 Paxos 是怎么实现一致性的?<a class="headerlink" href="#paxos" title="Link to this heading"></a></h2>
<section id="id12">
<h3>Paxos 协议<a class="headerlink" href="#id12" title="Link to this heading"></a></h3>
<p>Paxos 是 Leslie Lamport 提出的分布式一致性协议，专注于在不可靠的分布式环境中实现一致性。它是分布式系统中强一致性的理论基础。Paxos 的核心目标是确保多个节点（或称副本）在面对网络延迟、节点故障或消息丢失时，能够就某一值达成共识。</p>
</section>
<section id="id13">
<h3>Paxos 的基本概念<a class="headerlink" href="#id13" title="Link to this heading"></a></h3>
<p>在 Paxos 中，系统中的节点有三种角色：</p>
<ol class="arabic simple">
<li><p>Proposer（提议者）：</p></li>
</ol>
<ul class="simple">
<li><p>提议某个值给其他节点，希望该值能被采纳。</p></li>
<li><p>通常代表客户端的请求。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>Acceptor（接受者）：</p></li>
</ol>
<ul class="simple">
<li><p>决定是否接受一个提议（proposal）。</p></li>
<li><p>多个 Acceptor 组成一个“仲裁组”，用于保证一致性。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>Learner（学习者）：</p></li>
</ol>
<ul class="simple">
<li><p>学习最终被采纳的值。</p></li>
<li><p>通常用于将最终一致的值通知客户端或其他组件。</p></li>
</ul>
</section>
<section id="id14">
<h3>Paxos 的主要流程<a class="headerlink" href="#id14" title="Link to this heading"></a></h3>
<p>Paxos 协议分为两阶段实现一致性：Prepare 阶段和Accept 阶段。</p>
<ol class="arabic simple">
<li><p>Prepare 阶段（准备阶段）</p></li>
<li><p>Proposer 生成提案编号：
* 提议者生成一个唯一的提案编号（Proposal Number），确保编号递增且唯一。</p></li>
<li><p>发送 Prepare 请求：
* Proposer 将提案编号发送给所有 Acceptor，请求其承诺不再接受编号低于该提案的任何提议。</p></li>
<li><p>Acceptor 响应：</p></li>
</ol>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* 如果 Acceptor 收到的提案编号比自己之前承诺的编号更高，则承诺（Promise）：
* 不再接受编号低于该提案编号的任何提议。
* 返回它已经接受的编号最高的提案（如果有）。
</pre></div>
</div>
<ol class="arabic" start="2">
<li><p>Accept 阶段（接受阶段）</p>
<ol class="arabic simple">
<li><p>Proposer 决定提议值：</p></li>
</ol>
<ul class="simple">
<li><p>根据 Acceptor 返回的响应，Proposer 决定提议的值：</p></li>
<li><p>如果返回的提案中有已接受的值，则选择编号最高的提案值。</p></li>
<li><p>如果没有已接受的值，则选择一个新的值。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>发送 Accept 请求：</p></li>
</ol>
<ul class="simple">
<li><p>Proposer 将提案编号和提议值发送给所有 Acceptor，要求其接受该提案。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>Acceptor 响应：</p></li>
</ol>
<ul class="simple">
<li><p>如果接收到的提案编号仍然是它承诺过的最高编号，则接受该提案。</p></li>
<li><p>Acceptor 会将该提案存储，并通知 Learner。</p></li>
</ul>
</li>
</ol>
<p><strong>决议完成</strong></p>
<ul class="simple">
<li><p>当一个提案被大多数 Acceptor 接受时，该提案就被认为达成共识（Chosen）。</p></li>
<li><p>Learner 收到被接受的提案值后，将其传播到整个系统，使所有节点达成一致。</p></li>
</ul>
</section>
<section id="id15">
<h3>Paxos 的一致性保障<a class="headerlink" href="#id15" title="Link to this heading"></a></h3>
<p>Paxos 的一致性由以下原则保障：</p>
<ol class="arabic simple">
<li><p>提案编号递增性：</p></li>
</ol>
<ul class="simple">
<li><p>每次提案编号递增，确保更高编号的提案可以覆盖之前的提案。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>已接受提案的优先级：</p></li>
</ol>
<ul class="simple">
<li><p>如果某个提案已经被接受，则所有新的提案必须选择编号最高的已接受值，避免多个值被同时接受。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>多数派原则：</p></li>
</ol>
<ul class="simple">
<li><p>一个提案必须被多数 Acceptor 接受才能被认为达成一致，确保至少有一个 Acceptor 能与下一次提案的仲裁组重叠。</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>故障容忍性：</p></li>
</ol>
<ul class="simple">
<li><p>Paxos 能在多数 Acceptor 存活时继续运行，即使部分节点发生故障。</p></li>
</ul>
</section>
<section id="id16">
<h3>Paxos 的优点<a class="headerlink" href="#id16" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p>强一致性：</p></li>
</ol>
<ul class="simple">
<li><p>Paxos 在任何情况下都能保证只有一个提案值被最终达成共识。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>容错能力强：</p></li>
</ol>
<ul class="simple">
<li><p>Paxos 能容忍少量节点故障，只要超过一半的节点可用即可继续运行。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>理论完备性：</p></li>
</ol>
<ul class="simple">
<li><p>Paxos 是经过形式化验证的协议，确保其正确性。</p></li>
</ul>
</section>
<section id="id17">
<h3>Paxos 的缺点<a class="headerlink" href="#id17" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p>实现复杂：</p></li>
</ol>
<ul class="simple">
<li><p>Paxos 的流程较复杂，特别是多个角色的交互容易让实现者感到困惑。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>性能瓶颈：</p></li>
</ol>
<ul class="simple">
<li><p>Paxos 的通信轮次较多，每个提案需要经过两个阶段（Prepare 和 Accept），导致高延迟。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>难以扩展：</p></li>
</ol>
<ul class="simple">
<li><p>增加节点数量会显著提高网络通信开销，降低效率。</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>实际工程中的简化：</p></li>
</ol>
<ul class="simple">
<li><p>如 Raft 就简化了 Paxos 的复杂性，更适合工程实现。</p></li>
</ul>
</section>
<section id="id18">
<h3>Paxos 的改进版本<a class="headerlink" href="#id18" title="Link to this heading"></a></h3>
<p>为解决 Paxos 的性能问题，出现了许多改进版本：</p>
<ol class="arabic simple">
<li><p>Multi-Paxos：</p></li>
</ol>
<ul class="simple">
<li><p>避免每次提议都进行选举，Leader 可以直接处理后续提案，减少 Prepare 阶段的开销。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>Fast Paxos：</p></li>
</ol>
<ul class="simple">
<li><p>减少通信轮次，允许 Proposer 直接向 Acceptor 提交提案。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>EPaxos：</p></li>
</ol>
<ul class="simple">
<li><p>支持并行提案，减少延迟，提高性能。</p></li>
</ul>
</section>
<section id="id19">
<h3>总结<a class="headerlink" href="#id19" title="Link to this heading"></a></h3>
<p>Paxos 协议通过精巧的两阶段流程和多数派规则，在不可靠的分布式环境中实现了一致性。尽管 Paxos 是分布式一致性协议的理论基础，但由于实现复杂和性能瓶颈，在实际工程中通常使用其改进版（如 Multi-Paxos）或其他协议（如 Raft）。</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="spring_boot_faq.html" class="btn btn-neutral float-left" title="spring boot faq" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021 ~ 2035, Walter Fan, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>