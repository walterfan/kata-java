

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MySQL FAQ &mdash; Java handbook 1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=e536ea0c" />
      <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=29a6c3e3"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
      <script src="../_static/design-tabs.js?v=f930bc37"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Quarkus FAQ" href="quarkus_faq.html" />
    <link rel="prev" title="MyBatic FAQ" href="mybatis_faq.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Java handbook
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1.basic/index.html">1. Basic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2.library/index.html">2. Framework and Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3.middleware/index.html">3. Middleware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../4.architecture/index.html">4. Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../5.tips/index.html">5. Tips</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">6. FAQ</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="j2se_faq.html">Java FAQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="mybatis_faq.html">MyBatic FAQ</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">MySQL FAQ</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mysql">1. MySQL 有哪些事务隔离级别</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mysql-mvcc">2. MySQL 的多版本并发控制 MVCC 原理是什么?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#b-b">3. B 树与 B+ 树的区别是什么?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">4. 什么情况下使用索引会降低性能？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mysql-myisam-innodb">5. MySQL 中的MyISAM 和 InnoDB 有什么区别？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">6. MySQL 中的索引优化有哪些方法, 什么时候索引会失效？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sql">7. 什么是 SQL 索引的最左匹配原则</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">8. 如何对 MySQL 做性能优化, 有什么分析工具?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mysql-binlog">9. MySQL 的 binlog 有哪几种格式</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">10. MySQL 怎么实现主从同步</a></li>
<li class="toctree-l3"><a class="reference internal" href="#char-varchar">11. char 和 varchar 有什么区别</a></li>
<li class="toctree-l3"><a class="reference internal" href="#select">12. select 语句会加锁吗?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="quarkus_faq.html">Quarkus FAQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="spring_faq.html">Spring FAQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="spring_boot_faq.html">spring boot faq</a></li>
<li class="toctree-l2"><a class="reference internal" href="distribution_faq.html">Distributed System FAQ</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Java handbook</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">6. FAQ</a></li>
      <li class="breadcrumb-item active">MySQL FAQ</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/6.faq/mysql_faq.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="mysql-faq">
<h1>MySQL FAQ<a class="headerlink" href="#mysql-faq" title="Link to this heading"></a></h1>
<section id="mysql">
<h2>1. MySQL 有哪些事务隔离级别<a class="headerlink" href="#mysql" title="Link to this heading"></a></h2>
<p>MySQL 提供了以下四种事务隔离级别，用于控制不同事务之间的可见性和数据一致性。这些隔离级别按照从低到高的隔离性排列：</p>
<ol class="arabic simple">
<li><p>READ UNCOMMITTED（读取未提交）</p></li>
</ol>
<ul class="simple">
<li><p>描述：事务可以读取到其他事务尚未提交的数据（脏读）。</p></li>
<li><p>风险：可能发生脏读（Dirty Read）、不可重复读（Non-Repeatable Read）、幻读（Phantom Read）。</p></li>
<li><p>适用场景：几乎不用，因为隔离性最低，可能会导致严重的数据不一致问题。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>READ COMMITTED（读取已提交）</p></li>
</ol>
<ul class="simple">
<li><p>描述：事务只能读取到其他事务已提交的数据，避免了脏读。</p></li>
<li><p>风险：可能发生不可重复读和幻读。</p></li>
<li><p>适用场景：适用于大部分写多读少的业务场景，如金融系统。在 InnoDB 引擎中是 Oracle 默认的隔离级别。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>REPEATABLE READ（可重复读）</p></li>
</ol>
<ul class="simple">
<li><p>描述：在同一事务内的多次查询结果一致，即使其他事务已提交数据，当前事务中读取的数据不会变化。</p></li>
<li><p>风险：可能发生幻读。</p></li>
<li><p>适用场景：MySQL 的默认隔离级别。InnoDB 存储引擎通过 MVCC 和 间隙锁（next-key locking）机制解决了幻读问题，因此适合大多数应用场景。</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>SERIALIZABLE（可串行化）</p></li>
</ol>
<ul class="simple">
<li><p>描述：最高的隔离级别，所有事务按顺序执行，避免了脏读、不可重复读和幻读。</p></li>
<li><p>风险：可能引发大量锁定，导致性能降低。</p></li>
<li><p>适用场景：对数据一致性要求极高且并发性低的场景，但因为性能较低，通常不适用高并发系统。</p></li>
</ul>
<p>隔离级别对比表</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>隔离级别</p></th>
<th class="head"><p>脏读（Dirty Read）</p></th>
<th class="head"><p>不可重复读（Non-Repeatable Read）</p></th>
<th class="head"><p>幻读（Phantom Read）</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>READ UNCOMMITTED</p></td>
<td><p>可能</p></td>
<td><p>可能</p></td>
<td><p>可能</p></td>
</tr>
<tr class="row-odd"><td><p>READ COMMITTED</p></td>
<td><p>不可能</p></td>
<td><p>可能</p></td>
<td><p>可能</p></td>
</tr>
<tr class="row-even"><td><p>REPEATABLE READ</p></td>
<td><p>不可能</p></td>
<td><p>不可能</p></td>
<td><p>可能*（InnoDB 中已解决）</p></td>
</tr>
<tr class="row-odd"><td><p>SERIALIZABLE</p></td>
<td><p>不可能</p></td>
<td><p>不可能</p></td>
<td><p>不可能</p></td>
</tr>
</tbody>
</table>
<p>总结</p>
<p>MySQL 的默认隔离级别是 REPEATABLE READ，一般能满足绝大多数场景的需求，同时避免了大部分并发问题。根据业务需求选择适当的隔离级别，以在一致性和性能之间取得平衡。</p>
</section>
<section id="mysql-mvcc">
<h2>2. MySQL 的多版本并发控制 MVCC 原理是什么?<a class="headerlink" href="#mysql-mvcc" title="Link to this heading"></a></h2>
<p>MySQL 的多版本并发控制（MVCC, Multi-Version Concurrency Control）是一种用于提高数据库并发性能的机制，尤其是在事务隔离级别为 READ COMMITTED 和 REPEATABLE READ 时。MVCC 通过保存数据的多个版本，使读操作无需等待写操作完成，可以读取到事务特定的历史快照，从而避免锁争用。MySQL 的 InnoDB 存储引擎通过 MVCC 实现读操作的非阻塞性，并保证一致性。</p>
<p>MVCC 的实现原理</p>
<p>在 InnoDB 中，MVCC 依赖于隐藏字段和回滚日志，通过版本控制管理事务间的数据可见性：</p>
<ol class="arabic simple">
<li><p>隐藏字段：每行记录包含两个隐式的系统字段，用于 MVCC 管理。</p></li>
</ol>
<ul class="simple">
<li><p>创建版本号：表示插入该行数据的事务 ID。</p></li>
<li><p>删除版本号：表示删除该行数据的事务 ID。若该行未被删除，则为 NULL。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>事务 ID（Transaction ID）：每个事务启动时会分配一个唯一递增的事务 ID，后续操作以此 ID 进行标识。事务 ID 确定了事务对数据的可见性规则：</p></li>
</ol>
<ul class="simple">
<li><p>读取数据时，仅可见 创建版本号小于当前事务 ID 且 删除版本号为空或大于当前事务 ID 的记录。</p></li>
<li><p>这样可以确保事务只读到自己或已提交的其他事务的更改，避免未提交数据的读取。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>回滚日志（Undo Log）：</p></li>
</ol>
<ul class="simple">
<li><p>保存历史版本：每次更新数据时，InnoDB 会在回滚日志中存储数据的旧版本。回滚日志类似一个时间倒流的链表，每个数据更新都记录原始值，支持恢复旧版本。</p></li>
<li><p>事务快照：当事务开始时，InnoDB 会根据 Undo Log 和系统时间点生成一个一致性视图（快照），事务只读取符合当前快照的数据。</p></li>
</ul>
<p>MVCC 的实现细节与流程</p>
<ul class="simple">
<li><p>读操作：基于快照读，不加锁。</p></li>
<li><p>快照读：事务读取的记录符合创建版本号小于当前事务 ID 且删除版本号为空或大于当前事务 ID 的版本。快照读在 SELECT 操作中使用，避免阻塞读，具有更高的并发性。</p></li>
<li><p>当前读：某些情况下需要最新数据（如 SELECT … FOR UPDATE、UPDATE），会锁定行，并读取最新数据。</p></li>
<li><p>写操作：需要根据事务隔离级别选择合适的锁机制以确保数据一致性。</p></li>
<li><p>插入：为新记录写入创建版本号。</p></li>
<li><p>更新：生成新记录的创建版本号，旧版本的删除版本号设置为当前事务 ID。</p></li>
<li><p>删除：仅更新删除版本号，不真正删除数据，以便快照回溯。</p></li>
</ul>
<p>MVCC 的优势与限制</p>
<ul class="simple">
<li><p>优势：</p></li>
<li><p>读写分离：使得读操作不会阻塞写操作，实现无锁并发读。</p></li>
<li><p>性能提升：提高数据库的并发性能，减少锁争用，适合高并发应用场景。</p></li>
<li><p>事务一致性：不同事务看到的数据快照互相隔离，符合隔离级别要求。</p></li>
<li><p>限制：</p></li>
<li><p>只能用于 READ COMMITTED 和 REPEATABLE READ 隔离级别。SERIALIZABLE 需要加锁，不使用 MVCC。</p></li>
<li><p>存储开销：维护多个版本会占用更多存储空间，Undo Log 过多时需要清理和优化。</p></li>
</ul>
<p>总结</p>
<p>MySQL 的 MVCC 通过创建和删除版本号、回滚日志实现多版本数据管理，从而提高并发性能，降低锁竞争，保证事务隔离级别下的数据一致性。</p>
</section>
<section id="b-b">
<h2>3. B 树与 B+ 树的区别是什么?<a class="headerlink" href="#b-b" title="Link to this heading"></a></h2>
<p>B 树和B+ 树是用于实现数据库和文件系统的平衡树结构，它们都适用于高效地查找、插入和删除操作。以下是两者的主要区别：</p>
<ol class="arabic simple">
<li><p>结构差异</p></li>
</ol>
<ul class="simple">
<li><p>B 树：所有节点都存储键和数据。叶子节点和非叶子节点都可以存储数据（即每个节点都可以保存数据指针）。</p></li>
<li><p>B+ 树：只有叶子节点存储数据，而非叶子节点仅存储键，作为索引指向叶子节点。叶子节点形成一个链表，用于顺序查找。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>查询效率</p></li>
</ol>
<ul class="simple">
<li><p>B 树：在任何节点都可以查找到数据，因此查询时可能提前结束，访问层级较少。</p></li>
<li><p>B+ 树：必须在叶子节点才能找到数据，虽然查询需要更深的层级，但每层节点可容纳更多键，树的高度通常更小。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>范围查询和排序</p></li>
</ol>
<ul class="simple">
<li><p>B 树：不支持天然的顺序访问。要实现范围查找，可能需要遍历多个子树，性能不如 B+ 树。</p></li>
<li><p>B+ 树：叶子节点形成链表，可以顺序访问，天然适合范围查询。因此，B+ 树特别适合区间查询和排序操作。</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>空间利用率</p></li>
</ol>
<ul class="simple">
<li><p>B 树：非叶子节点存储数据，占用更多空间。</p></li>
<li><p>B+ 树：非叶子节点只存储键而不存储数据，因此可以在相同高度下容纳更多节点，节省空间，且 IO 性能更好。</p></li>
</ul>
<ol class="arabic simple" start="5">
<li><p>数据冗余</p></li>
</ol>
<ul class="simple">
<li><p>B 树：数据只存储在一个位置。</p></li>
<li><p>B+ 树：叶子节点间有链表结构，叶子节点的顺序性使得数据更为冗余，但增加了查找效率。</p></li>
</ul>
<p>总结</p>
<p>B 树适合随机查找，不需频繁范围查询的场景；B+ 树因其顺序结构更适合数据库、文件系统的范围查询和排序操作，因此应用更广泛。</p>
</section>
<section id="id1">
<h2>4. 什么情况下使用索引会降低性能？<a class="headerlink" href="#id1" title="Link to this heading"></a></h2>
<p>在数据库中，索引通常可以提高查询速度，但在某些特定情况下，索引反而会降低性能，原因包括索引的维护开销和查询优化不足。以下是一些使用索引可能降低性能的情况：</p>
<ol class="arabic simple">
<li><p>小数据集</p></li>
</ol>
<ul class="simple">
<li><p>原因：如果表的数据量很小，直接扫描全表的速度比通过索引查询更快。</p></li>
<li><p>解决方案：对于小表，避免不必要的索引创建，可以更快地完成简单查询。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>高频增删改操作</p></li>
</ol>
<ul class="simple">
<li><p>原因：每次插入、更新、删除操作都需要同时维护索引，这会带来额外的开销。</p></li>
<li><p>影响：大量写操作时，索引会影响插入和更新性能，尤其是在多列索引上。</p></li>
<li><p>解决方案：在写密集型应用中减少不必要的索引，或选择合适的索引类型。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>低选择性列</p></li>
</ol>
<ul class="simple">
<li><p>原因：对低选择性（如性别、布尔值等）的列建立索引不会显著减少数据扫描量。</p></li>
<li><p>影响：索引可能并未有效过滤数据，还会带来额外的维护开销。</p></li>
<li><p>解决方案：避免对低选择性列创建索引；在某些情况下，可选择组合索引。</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>模糊查询或非前缀匹配</p></li>
</ol>
<ul class="simple">
<li><p>原因：对于使用 % 通配符开头的 LIKE 查询，或非 B 树前缀匹配的查询，索引通常不起作用。</p></li>
<li><p>解决方案：尽量使用前缀匹配的 LIKE 查询，例如 “name LIKE ‘abc%’，以便索引生效；或使用全文索引。</p></li>
</ul>
<ol class="arabic simple" start="5">
<li><p>复杂多条件查询</p></li>
</ol>
<ul class="simple">
<li><p>原因：复杂查询中如果条件和索引不匹配（如查询使用的条件列顺序与索引列顺序不同），可能会导致索引无法完全发挥作用。</p></li>
<li><p>解决方案：优化查询条件，使用复合索引，或调优 SQL 以匹配索引顺序。</p></li>
</ul>
<ol class="arabic simple" start="6">
<li><p>索引过多</p></li>
</ol>
<ul class="simple">
<li><p>原因：为每个查询需求添加单独的索引会增加数据维护的负担，影响写入性能。</p></li>
<li><p>解决方案：根据查询情况合并多列索引；定期评估并删除不必要的索引。</p></li>
</ul>
<ol class="arabic simple" start="7">
<li><p>排序字段与索引不匹配</p></li>
</ol>
<ul class="simple">
<li><p>原因：如果查询的排序字段未被索引或索引顺序不合适，数据库会进行额外排序操作。</p></li>
<li><p>解决方案：为排序字段添加合适的索引，或优化 SQL 使其匹配索引顺序。</p></li>
</ul>
<ol class="arabic simple" start="8">
<li><p>频繁更新索引列</p></li>
</ol>
<ul class="simple">
<li><p>原因：索引列的频繁更新会导致索引不断重建和调整，影响性能。</p></li>
<li><p>解决方案：避免对频繁更新的列建立索引。</p></li>
</ul>
<p>总结</p>
<p>索引的创建要根据数据分布、查询模式和性能需求权衡。合理设计索引可以提高查询性能，避免不必要的索引创建和维护开销，以优化数据库的整体性能。</p>
</section>
<section id="mysql-myisam-innodb">
<h2>5. MySQL 中的MyISAM 和 InnoDB 有什么区别？<a class="headerlink" href="#mysql-myisam-innodb" title="Link to this heading"></a></h2>
<p>MySQL 中的 MyISAM 和 InnoDB 是两种常用的存储引擎，它们的主要区别包括数据存储、事务支持、锁机制、外键支持等。以下是详细的对比：</p>
<ol class="arabic simple">
<li><p>事务支持</p></li>
</ol>
<ul class="simple">
<li><p>MyISAM：不支持事务，因此无法进行回滚、提交和事务控制，适合事务一致性要求较低的应用。</p></li>
<li><p>InnoDB：支持 ACID 事务，通过提交、回滚和崩溃恢复来确保数据一致性，适用于对事务有严格要求的应用。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>锁机制</p></li>
</ol>
<ul class="simple">
<li><p>MyISAM：使用表级锁，每次执行增删改查操作都会锁定整个表，适用于以查询为主、写操作较少的场景。</p></li>
<li><p>InnoDB：使用行级锁（也支持表级锁），仅锁定需要操作的行，能更好地支持高并发，适合频繁读写的应用。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>外键支持</p></li>
</ol>
<ul class="simple">
<li><p>MyISAM：不支持外键约束。</p></li>
<li><p>InnoDB：支持外键约束，确保数据的参照完整性。</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>数据存储与恢复</p></li>
</ol>
<ul class="simple">
<li><p>MyISAM：将数据、索引分别存储在不同文件中。表在崩溃后恢复较困难，需要手动修复。</p></li>
<li><p>InnoDB：将表数据和索引保存在同一个表空间文件（或独立文件中，取决于配置），支持自动崩溃恢复，数据更安全。</p></li>
</ul>
<ol class="arabic simple" start="5">
<li><p>表空间和文件结构</p></li>
</ol>
<ul class="simple">
<li><p>MyISAM：每个表会生成三个文件，.frm（表结构）、.MYD（数据）、.MYI（索引）。</p></li>
<li><p>InnoDB：使用共享表空间或独立表空间来存储数据和索引，数据和索引会存储在 .ibd 文件中（独立表空间）。</p></li>
</ul>
<ol class="arabic simple" start="6">
<li><p>全文索引</p></li>
</ol>
<ul class="simple">
<li><p>MyISAM：原生支持全文索引，适合对文本进行全文搜索的场景。</p></li>
<li><p>InnoDB：从 MySQL 5.6 开始支持全文索引，但性能不及 MyISAM。</p></li>
</ul>
<ol class="arabic simple" start="7">
<li><p>性能和应用场景</p></li>
</ol>
<ul class="simple">
<li><p>MyISAM：适合读密集型应用，如数据分析、日志记录，读性能较高。</p></li>
<li><p>InnoDB：适合事务密集型应用和高并发场景，如在线交易、金融系统等。</p></li>
</ul>
<ol class="arabic simple" start="8">
<li><p>存储空间占用</p></li>
</ol>
<ul class="simple">
<li><p>MyISAM：相对较小，尤其是在不需要事务的情况下，MyISAM 表的存储空间利用率更高。</p></li>
<li><p>InnoDB：因支持事务和数据恢复，维护 MVCC，因此比 MyISAM 占用更多存储空间。</p></li>
</ul>
<ol class="arabic simple" start="9">
<li><p>数据的可恢复性</p></li>
</ol>
<ul class="simple">
<li><p>MyISAM：崩溃后可能导致数据丢失，恢复较为困难。</p></li>
<li><p>InnoDB：通过重做日志（redo log）和撤销日志（undo log）实现崩溃恢复，确保数据安全。</p></li>
</ul>
<p>总结</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>特性</p></th>
<th class="head"><p>MyISAM</p></th>
<th class="head"><p>InnoDB</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>事务支持</p></td>
<td><p>不支持</p></td>
<td><p>支持</p></td>
</tr>
<tr class="row-odd"><td><p>锁机制</p></td>
<td><p>表级锁</p></td>
<td><p>行级锁、表级锁</p></td>
</tr>
<tr class="row-even"><td><p>外键</p></td>
<td><p>不支持</p></td>
<td><p>支持</p></td>
</tr>
<tr class="row-odd"><td><p>数据恢复</p></td>
<td><p>较难恢复</p></td>
<td><p>自动恢复</p></td>
</tr>
<tr class="row-even"><td><p>存储文件结构</p></td>
<td><p>.MYD、.MYI 文件</p></td>
<td><p>.ibd 文件</p></td>
</tr>
<tr class="row-odd"><td><p>全文索引</p></td>
<td><p>支持（效率更高）</p></td>
<td><p>支持（MySQL 5.6+）</p></td>
</tr>
<tr class="row-even"><td><p>性能</p></td>
<td><p>读操作快</p></td>
<td><p>高并发、写操作性能好</p></td>
</tr>
<tr class="row-odd"><td><p>适用场景</p></td>
<td><p>读多写少</p></td>
<td><p>事务密集、高并发应用</p></td>
</tr>
<tr class="row-even"><td><p>崩溃恢复</p></td>
<td><p>手动</p></td>
<td><p>自动</p></td>
</tr>
</tbody>
</table>
<p>选择建议：如果应用对事务支持、数据完整性和并发要求较高，选择 InnoDB。对于只读多写少、事务要求低的场景，MyISAM 是更好的选择。</p>
</section>
<section id="id2">
<h2>6. MySQL 中的索引优化有哪些方法, 什么时候索引会失效？<a class="headerlink" href="#id2" title="Link to this heading"></a></h2>
<p>MySQL 中的索引优化方法</p>
<ol class="arabic simple">
<li><p>选择合适的索引类型</p></li>
</ol>
<ul class="simple">
<li><p>B-tree 索引：适用于大多数查询，特别是范围查询、等值查询。</p></li>
<li><p>哈希索引：适用于等值查询，但不能用于范围查询。</p></li>
<li><p>全文索引（Full-Text Index）：适用于对文本字段进行搜索，支持 MATCH … AGAINST 查询。</p></li>
<li><p>空间索引（Spatial Index）：用于地理空间数据类型的索引。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>创建复合索引</p></li>
</ol>
<ul class="simple">
<li><p>对于多列查询，使用复合索引（联合索引）而不是单列索引。复合索引能优化多个列的查询条件，避免多个索引的扫描。</p></li>
<li><p>复合索引的列顺序要根据查询条件的使用频率和过滤效果来设计，通常选择最常用的列放在前面。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>避免过多的索引</p></li>
</ol>
<ul class="simple">
<li><p>创建索引虽然提高了查询速度，但也会降低写操作（插入、更新、删除）的性能。合理设计索引，避免为每个查询都创建索引。</p></li>
<li><p>可以通过 EXPLAIN 查询分析，找出未使用的索引，并删除它们。</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>避免索引覆盖的冗余查询</p></li>
</ol>
<ul class="simple">
<li><p>如果查询只需要索引中存在的列，可以通过索引覆盖查询来提升性能。通过选择性字段进行查询，使查询的返回数据完全在索引中，而不需要访问数据表。</p></li>
</ul>
<ol class="arabic simple" start="5">
<li><p>优化查询条件</p></li>
</ol>
<ul class="simple">
<li><p>使用等值查询和范围查询时，尽量将 = 条件放在前面。避免使用 OR 连接多个不同的列条件（因为 OR 会导致索引失效）。</p></li>
<li><p>将常常使用的查询条件和索引列匹配，提高查询效率。</p></li>
</ul>
<ol class="arabic simple" start="6">
<li><p>避免在索引列上使用函数</p></li>
</ol>
<ul class="simple">
<li><p>在索引列上使用函数（如 LOWER(), YEAR() 等）会导致索引失效，因为 MySQL 需要对每一行的列值进行函数计算，无法直接利用索引。</p></li>
</ul>
<ol class="arabic simple" start="7">
<li><p>合理使用覆盖索引</p></li>
</ol>
<ul class="simple">
<li><p>覆盖索引（Covering Index）是指查询中需要的所有列都包含在索引中，从而避免了回表操作，极大提高查询效率。</p></li>
</ul>
<ol class="arabic simple" start="8">
<li><p>定期分析和优化索引</p></li>
</ol>
<ul class="simple">
<li><p>使用 ANALYZE TABLE 进行表的统计信息更新，确保优化器能够选择最优的执行计划。</p></li>
<li><p>使用 OPTIMIZE TABLE 进行表的碎片整理，避免索引过多的碎片影响性能。</p></li>
</ul>
<p>索引失效的情况:</p>
<ol class="arabic simple">
<li><p>使用 OR 连接条件</p></li>
</ol>
<ul class="simple">
<li><p>当查询中使用了 OR 连接多个条件时，MySQL 会选择其中一个条件使用索引，其他条件可能无法使用索引，从而导致索引失效。</p></li>
<li><p>解决方法：尽量避免在多个列上使用 OR，或者将多个条件分开成独立的查询。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>使用函数或者计算表达式</p></li>
</ol>
<ul class="simple">
<li><p>在索引列上使用函数（如 LOWER(col)，YEAR(date)）或进行数学计算时，MySQL 不能利用索引。</p></li>
<li><p>解决方法：避免在索引列上使用函数或表达式，尽量将查询条件写为简单的列值比较。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>使用 LIKE 的通配符</p></li>
</ol>
<ul class="simple">
<li><p>使用 LIKE 查询时，如果通配符 % 在查询字符串的开头，例如 LIKE ‘%value’，MySQL 将无法使用索引。</p></li>
<li><p>解决方法：避免在 LIKE 查询中使用前缀通配符，或者考虑使用全文索引（MATCH）。</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>数据类型不匹配</p></li>
</ol>
<ul class="simple">
<li><p>如果查询条件中的数据类型与索引列的数据类型不匹配，索引可能会失效。</p></li>
<li><p>解决方法：确保查询时使用的列数据类型与索引列的数据类型一致。</p></li>
</ul>
<ol class="arabic simple" start="5">
<li><p>NULL 值的影响</p></li>
</ol>
<ul class="simple">
<li><p>对于包含 NULL 值的列，索引可能会失效，尤其是在条件中使用 IS NULL 或 IS NOT NULL 时。</p></li>
<li><p>解决方法：对于包含大量 NULL 值的列，尽量避免在查询中进行 NULL 判断，或者在查询中添加其他条件。</p></li>
</ul>
<ol class="arabic simple" start="6">
<li><p>DISTINCT 和 GROUP BY 中的列顺序</p></li>
</ol>
<ul class="simple">
<li><p>在使用 DISTINCT 或 GROUP BY 时，如果这些列没有按照索引顺序排列，MySQL 可能无法利用索引进行查询优化。</p></li>
<li><p>解决方法：确保 GROUP BY 或 DISTINCT 查询的列顺序与索引列的顺序匹配。</p></li>
</ul>
<ol class="arabic simple" start="7">
<li><p>多列索引列的顺序不合适</p></li>
</ol>
<ul class="simple">
<li><p>在多列索引（复合索引）中，查询条件的列顺序如果与索引中的列顺序不匹配，索引可能无法有效使用。</p></li>
<li><p>解决方法：调整查询条件的顺序，确保最常使用的列排在索引的前面。</p></li>
</ul>
<p>总结</p>
<p>优化索引是数据库性能调优的重要手段，但也需要根据具体的查询场景合理设计索引。通过定期分析查询执行计划，删除无用索引和优化查询条件，可以有效提高 MySQL 的查询性能。</p>
</section>
<section id="sql">
<h2>7. 什么是 SQL 索引的最左匹配原则<a class="headerlink" href="#sql" title="Link to this heading"></a></h2>
<p>SQL 索引的最左匹配原则是指，当查询中使用复合索引（即多列索引）时，MySQL 会优先使用索引的最左边的列进行匹配，并且必须从索引的最左边列开始匹配查询条件。如果查询的条件没有遵循最左匹配规则，索引将不能被有效利用。</p>
<p>具体规则：</p>
<ol class="arabic simple">
<li><p>必须从最左边的列开始匹配：对于一个多列复合索引，查询条件必须从最左边的列开始匹配。如果查询条件不包括最左边的列，或者列的顺序不符合索引顺序，那么索引将无法被使用。</p></li>
<li><p>可以匹配连续的列：一旦匹配了最左边的列，可以继续使用复合索引中的其他列，前提是查询条件中的这些列在索引中按顺序出现。</p></li>
<li><p>跳过中间列会导致索引失效：如果查询条件中跳过了复合索引中间的某些列（例如：查询条件没有包含第一个列，但是包含了第二个和第三个列），那么索引会失效。</p></li>
</ol>
<p>示例说明：</p>
<p>假设我们有一个复合索引：INDEX (col1, col2, col3)。</p>
<p>有效查询：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">col1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">col2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="p">;</span>
</pre></div>
</div>
<p>这个查询可以利用复合索引，因为查询条件中包含了最左边的列 col1 和 col2，并且它们是索引中的前两列。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">col1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">col2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">col3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="p">;</span>
</pre></div>
</div>
<p>这个查询条件同时使用了索引中的前三列，完全符合最左匹配原则，因此也可以使用索引。</p>
<p>无效查询：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SELECT * FROM table WHERE col2 = ? AND col3 = ?;
</pre></div>
</div>
<p>这个查询不会使用复合索引，因为它没有从最左边的列 col1 开始查询，导致索引失效。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SELECT * FROM table WHERE col3 = ?;
</pre></div>
</div>
<p>仅仅使用 col3 来查询，同样不会使用复合索引，因为 col3 不是最左边的列，并且查询条件跳过了 col1 和 col2。</p>
<p>可以使用索引的例外情况：</p>
<ul class="simple">
<li><p>范围查询：如果查询条件中存在范围查询（如 BETWEEN、&gt;, &lt; 等），那么索引会停止使用之后的列。也就是说，即使后续列符合最左匹配原则，但只要包含了范围查询，索引只能作用于到该范围查询的列。</p></li>
<li><p>有效例子：</p></li>
</ul>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">col1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">col2</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">?</span><span class="p">;</span>
</pre></div>
</div>
<p>这里，col1 是最左边的列，可以使用索引，col2 是范围查询，但后续列就不会被索引使用。</p>
<p>总结</p>
<p>最左匹配原则要求查询条件从复合索引的最左边的列开始匹配，并且可以连续匹配索引中后续的列。当查询条件跳过索引的某些列时，索引将无法被有效使用，这可能导致查询性能下降。为了确保复合索引能够发挥作用，需要合理设计查询条件和索引列的顺序。</p>
</section>
<section id="id3">
<h2>8. 如何对 MySQL 做性能优化, 有什么分析工具?<a class="headerlink" href="#id3" title="Link to this heading"></a></h2>
<p>MySQL 性能优化是一个综合的过程，涉及查询优化、硬件资源管理、配置调整等多个方面。以下是一些常见的 MySQL 性能优化方法以及可用的分析工具：</p>
<p>MySQL 性能优化方法</p>
<ol class="arabic simple">
<li><p>查询优化</p></li>
</ol>
<ul class="simple">
<li><p>使用合适的索引：确保查询条件使用了合适的索引，尤其是复合索引。</p></li>
<li><p>避免全表扫描：尽量避免对大表的全表扫描，尤其是没有索引支持的情况下。</p></li>
<li><p>避免不必要的 JOIN：避免在查询中使用不必要的 JOIN，减少查询复杂度。</p></li>
<li><p>避免 SELECT *：只选择需要的列，避免返回过多数据。</p></li>
<li><p>优化子查询：将子查询替换为 JOIN，提高查询效率。</p></li>
<li><p>合理使用 GROUP BY 和 ORDER BY：这些操作需要排序，优化时要注意它们的开销，尽量避免对大数据集进行排序。</p></li>
<li><p>减少临时表使用：避免在查询中生成不必要的临时表，尤其是对大表进行排序时。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>索引优化</p></li>
</ol>
<ul class="simple">
<li><p>选择合适的索引类型：如 B-tree 索引、哈希索引、全文索引等。</p></li>
<li><p>避免过多索引：虽然索引可以加速查询，但过多的索引会影响插入、更新和删除操作的性能。</p></li>
<li><p>索引覆盖：使用覆盖索引来避免回表操作，提高查询性能。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>表结构优化</p></li>
</ol>
<ul class="simple">
<li><p>规范化数据模型：避免数据冗余，确保数据的规范化。</p></li>
<li><p>分区表：对于非常大的表，可以考虑使用分区表，以提高查询性能。</p></li>
<li><p>数据类型优化：选择适合的字段类型，避免使用不必要的 VARCHAR 或 TEXT 类型，尽量使用整数类型来提高存储和查询效率。</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>缓存优化</p></li>
</ol>
<ul class="simple">
<li><p>Query Cache：开启 query_cache 可以缓存查询结果，但需要注意对于高并发环境，query_cache 可能成为瓶颈，MySQL 5.7 后已经逐步弃用。</p></li>
<li><p>使用外部缓存：如 Redis 或 Memcached，用于缓存热点数据，减轻数据库压力。</p></li>
<li><p>InnoDB Buffer Pool：适当调整 InnoDB 的缓存大小（innodb_buffer_pool_size），以减少磁盘 I/O，提高读取性能。</p></li>
</ul>
<ol class="arabic simple" start="5">
<li><p>配置调整</p></li>
</ol>
<ul class="simple">
<li><p>调整 innodb_buffer_pool_size：增大 InnoDB 缓冲池的大小，使更多的数据能够缓存到内存中，减少磁盘访问。</p></li>
<li><p>调整 max_connections：根据实际负载调整最大连接数，防止资源耗尽。</p></li>
<li><p>优化日志：合理配置 慢查询日志 和 通用查询日志，便于分析性能瓶颈。</p></li>
<li><p>调整 tmp_table_size 和 max_heap_table_size：增大这些参数可以避免生成临时磁盘表，提升查询性能。</p></li>
</ul>
<ol class="arabic simple" start="6">
<li><p>硬件优化</p></li>
</ol>
<ul class="simple">
<li><p>硬件资源：为 MySQL 配置足够的 CPU、内存和快速的磁盘（如 SSD），尤其是在高并发环境下。</p></li>
<li><p>RAID 配置：选择合适的 RAID 级别（如 RAID 10）来提升 I/O 性能。</p></li>
</ul>
<ol class="arabic simple" start="7">
<li><p>连接池优化</p></li>
</ol>
<ul class="simple">
<li><p>使用连接池：避免每次查询时都重新建立连接，使用连接池减少连接开销。</p></li>
</ul>
<p>MySQL 性能分析工具</p>
<ol class="arabic simple">
<li><p>MySQL EXPLAIN</p></li>
</ol>
<ul class="simple">
<li><p>功能：通过 EXPLAIN 命令，分析查询的执行计划，了解 MySQL 如何使用索引、连接表以及读取顺序。</p></li>
<li><p>用途：帮助开发者查看查询是否利用了索引，是否有不必要的全表扫描等。</p></li>
</ul>
<p>示例：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">department</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;HR&#39;</span><span class="p">;</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>MySQL 慢查询日志</p></li>
</ol>
<ul class="simple">
<li><p>功能：记录执行时间较长的 SQL 查询，可以通过该日志来识别性能瓶颈。</p></li>
<li><p>用途：分析哪些查询消耗了较多时间，进一步优化这些查询。</p></li>
<li><p>开启方式：</p></li>
</ul>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SET</span><span class="w"> </span><span class="k">GLOBAL</span><span class="w"> </span><span class="n">slow_query_log</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;ON&#39;</span><span class="p">;</span>
<span class="k">SET</span><span class="w"> </span><span class="k">GLOBAL</span><span class="w"> </span><span class="n">long_query_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">-- 查询时间超过 1 秒的会被记录</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>MySQL Performance Schema</p></li>
</ol>
<ul class="simple">
<li><p>功能：用于监控 MySQL 服务器的各项指标，如线程、锁、表等。</p></li>
<li><p>用途：可以详细了解 MySQL 在运行中的各项性能数据，进行深入的分析。</p></li>
</ul>
<p>示例：查询当前查询的执行状态</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">performance_schema</span><span class="p">.</span><span class="n">events_statements_current</span><span class="p">;</span>
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li><p>MySQL Enterprise Monitor</p></li>
</ol>
<ul class="simple">
<li><p>功能：MySQL 官方提供的监控工具，提供详细的数据库性能指标，帮助进行性能优化。</p></li>
<li><p>用途：实时监控 MySQL 实例，检查数据库性能瓶颈，自动生成优化建议。</p></li>
</ul>
<ol class="arabic simple" start="5">
<li><p>Percona Toolkit</p></li>
</ol>
<ul class="simple">
<li><p>功能：Percona 提供的一系列命令行工具，用于数据库性能分析和优化。</p></li>
<li><p>工具：</p></li>
<li><p>pt-query-digest：分析慢查询日志，帮助优化 SQL。</p></li>
<li><p>pt-online-schema-change：在不锁表的情况下进行表结构变更。</p></li>
</ul>
<ol class="arabic simple" start="6">
<li><p>Mytop</p></li>
</ol>
<ul class="simple">
<li><p>功能：类似于 top 命令，实时监控 MySQL 的性能，包括查询、连接、缓存等信息。</p></li>
<li><p>用途：快速查看 MySQL 实例的性能，实时发现性能问题。</p></li>
</ul>
<ol class="arabic simple" start="7">
<li><p>sys schema</p></li>
</ol>
<ul class="simple">
<li><p>功能：MySQL 自带的 sys 模式包含一组视图，用于帮助简化 MySQL 性能调优分析，提供更为高效的统计数据。</p></li>
<li><p>用途：通过该模式可以方便地获取服务器状态、查询统计等信息。</p></li>
</ul>
<ol class="arabic simple" start="8">
<li><p>Grafana + Prometheus</p></li>
</ol>
<ul class="simple">
<li><p>功能：通过 Prometheus 收集 MySQL 性能指标，并通过 Grafana 展示图表，实时监控 MySQL 性能。</p></li>
<li><p>用途：适合大规模 MySQL 集群的性能监控和数据可视化。</p></li>
</ul>
<ol class="arabic simple" start="9">
<li><p>pt-deadlock-logger</p></li>
</ol>
<ul class="simple">
<li><p>功能：用于检测和记录 MySQL 死锁。</p></li>
<li><p>用途：当 MySQL 发生死锁时，该工具可以帮助分析死锁情况并找出瓶颈。</p></li>
</ul>
<p>总结</p>
<p>MySQL 性能优化是一个持续的过程，包括查询优化、索引优化、表结构优化、缓存和硬件优化等方面。同时，利用合适的工具（如 EXPLAIN、慢查询日志、Performance Schema 和 Percona Toolkit）来分析和监控数据库性能，是优化 MySQL 性能的关键步骤。</p>
</section>
<section id="mysql-binlog">
<h2>9. MySQL 的 binlog 有哪几种格式<a class="headerlink" href="#mysql-binlog" title="Link to this heading"></a></h2>
<p>MySQL 的 binary log（binlog）有三种格式，每种格式的行为和日志记录方式不同。它们分别是：</p>
<ol class="arabic simple">
<li><p>Statement-Based Replication (SBR) 语句级复制</p></li>
</ol>
<ul class="simple">
<li><p>描述：在这种格式下，MySQL 会记录执行的 SQL 语句而不是记录具体的数据变动。主库上的每条 SQL 语句会被完整地复制到从库执行。</p></li>
<li><p>优点：</p></li>
<li><p>语句较为简洁，日志体积小，网络传输效率高。</p></li>
<li><p>对于大多数的简单查询和操作，效率较高。</p></li>
<li><p>缺点：</p></li>
<li><p>由于 SQL 语句仅仅是原样复制，某些涉及随机数、时间、或不同数据库环境的操作可能导致从库的执行结果不一致。</p></li>
<li><p>某些语句，如 NOW() 或 UUID() 等，依赖于主库的环境，可能导致主从数据不一致。</p></li>
<li><p>应用场景：适用于不涉及函数、非确定性操作的应用。</p></li>
</ul>
<p>设置：</p>
<p>SET GLOBAL binlog_format = ‘STATEMENT’;</p>
<ol class="arabic simple" start="2">
<li><p>Row-Based Replication (RBR) 行级复制</p></li>
</ol>
<ul class="simple">
<li><p>描述：行级复制记录的是数据行的实际变动，而不是 SQL 语句。这意味着在 binlog 中会记录哪些表的哪一行被修改了。</p></li>
<li><p>优点：</p></li>
<li><p>复制的数据更精确，能够准确地反映每一行数据的变化，避免了由语句执行带来的不一致问题。</p></li>
<li><p>对于某些特定的操作（例如涉及时间戳或随机数的操作），不会产生主从数据不一致的情况。</p></li>
<li><p>缺点：</p></li>
<li><p>由于记录的是数据变动（每一行的变化），日志体积较大。</p></li>
<li><p>日志较为冗长，增加了网络传输和存储负担。</p></li>
<li><p>应用场景：适用于数据变动较为复杂且希望确保主从一致性的场景。</p></li>
</ul>
<p>设置：</p>
<p>SET GLOBAL binlog_format = ‘ROW’;</p>
<ol class="arabic simple" start="3">
<li><p>Mixed-Based Replication (MBR) 混合复制</p></li>
</ol>
<ul class="simple">
<li><p>描述：混合复制是 MySQL 自动选择使用 SBR 或 RBR 的方式。它结合了 Statement-Based 和 Row-Based 复制的优点，根据不同的场景选择最合适的格式：</p></li>
<li><p>对于简单的语句（如 UPDATE、DELETE），使用 SBR。</p></li>
<li><p>对于复杂的语句（如 UPDATE 语句中包含了 UUID() 或 NOW() 函数），使用 RBR。</p></li>
<li><p>优点：</p></li>
<li><p>提供了较好的平衡，避免了 SBR 和 RBR 的局限性。</p></li>
<li><p>在大多数情况下可以自动选择最适合的复制方式。</p></li>
<li><p>缺点：</p></li>
<li><p>由于自动切换，不太适合需要完全掌控日志格式的场景。</p></li>
<li><p>应用场景：适合大多数常见的应用，可以根据实际情况动态选择适合的复制方式。</p></li>
</ul>
<p>设置：</p>
<p>SET GLOBAL binlog_format = ‘MIXED’;</p>
<p>总结：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>格式</p></th>
<th class="head"><p>描述</p></th>
<th class="head"><p>优点</p></th>
<th class="head"><p>缺点</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Statement-Based</p></td>
<td><p>记录 SQL 语句</p></td>
<td><p>日志体积小，效率较高</p></td>
<td><p>可能导致主从数据不一致，尤其是非确定性操作</p></td>
</tr>
<tr class="row-odd"><td><p>Row-Based</p></td>
<td><p>记录数据行的变动</p></td>
<td><p>精确记录数据变化，主从数据一致</p></td>
<td><p>日志体积大，增加存储和网络开销</p></td>
</tr>
<tr class="row-even"><td><p>Mixed-Based</p></td>
<td><p>语句级与行级结合，根据情况自动选择</p></td>
<td><p>自动选择最适合的复制方式</p></td>
<td><p>需要自动切换，不适合完全控制复制方式</p></td>
</tr>
</tbody>
</table>
<p>选择合适的 binlog 格式取决于你的应用场景、数据一致性要求、以及性能需求。</p>
</section>
<section id="id4">
<h2>10. MySQL 怎么实现主从同步<a class="headerlink" href="#id4" title="Link to this heading"></a></h2>
<p>MySQL 的主从同步（Master-Slave Replication）是指将一个 MySQL 实例（主服务器，Master）上的数据同步到另一个或多个 MySQL 实例（从服务器，Slave）。这种同步是异步的，即主服务器执行写操作时不会等待从服务器的确认。主从同步可以用于负载均衡、数据备份、高可用性等场景。</p>
<p>MySQL 主从同步的实现原理</p>
<ol class="arabic simple">
<li><p>主服务器（Master）</p></li>
</ol>
<ul class="simple">
<li><p>主服务器记录所有数据的变更操作（如 INSERT、UPDATE、DELETE）到 binary log（binlog）中。binlog 记录的内容用于同步到从服务器。</p></li>
<li><p>主服务器使用一个唯一的 log position（日志位置）来标识当前写入的 binlog 的位置。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>从服务器（Slave）</p></li>
</ol>
<ul class="simple">
<li><p>从服务器连接到主服务器，并从主服务器的 binlog 中读取变更数据，逐条执行这些变更。</p></li>
<li><p>从服务器记录下已经同步到的 binlog 位置，确保从该位置开始同步。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>同步过程</p></li>
</ol>
<ul class="simple">
<li><p>主服务器：在主服务器上，所有的写操作（如插入、更新和删除）都会被记录到 binlog 中。</p></li>
<li><p>从服务器：从服务器通过 I/O 线程 获取主服务器的 binlog 并将其存储在本地。接着，从服务器通过 SQL 线程 执行这些变更。</p></li>
<li><p>从服务器在执行 SQL 线程时，会按照主服务器发送的 binlog 操作来更新自己的数据库。</p></li>
</ul>
<p>配置 MySQL 主从同步</p>
<ol class="arabic simple">
<li><p>配置主服务器（Master）</p></li>
</ol>
<ol class="arabic simple">
<li><p>启用 binlog：在主服务器的配置文件（my.cnf 或 my.ini）中启用 binlog 记录，确保主服务器记录所有更改：</p></li>
</ol>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[mysqld]</span>
<span class="na">log-bin</span><span class="o">=</span><span class="s">mysql-bin</span><span class="w">      </span><span class="c1"># 启用二进制日志</span>
<span class="na">server-id</span><span class="o">=</span><span class="s">1</span><span class="w">            </span><span class="c1"># 为主服务器指定唯一的 server-id</span>
<span class="na">binlog-do-db</span><span class="o">=</span><span class="s">test</span><span class="w">      </span><span class="c1"># 指定要同步的数据库（可选）</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>重启主服务器：</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sudo<span class="w"> </span>service<span class="w"> </span>mysql<span class="w"> </span>restart
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>创建复制账户：在主服务器上创建一个用于从服务器连接的账户，并授予 REPLICATION SLAVE 权限：</p></li>
</ol>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">USER</span><span class="w"> </span><span class="s1">&#39;replication_user&#39;</span><span class="o">@</span><span class="s1">&#39;%&#39;</span><span class="w"> </span><span class="n">IDENTIFIED</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="s1">&#39;password&#39;</span><span class="p">;</span>
<span class="k">GRANT</span><span class="w"> </span><span class="n">REPLICATION</span><span class="w"> </span><span class="n">SLAVE</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="o">*</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="k">TO</span><span class="w"> </span><span class="s1">&#39;replication_user&#39;</span><span class="o">@</span><span class="s1">&#39;%&#39;</span><span class="p">;</span>
<span class="n">FLUSH</span><span class="w"> </span><span class="k">PRIVILEGES</span><span class="p">;</span>
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li><p>获取主服务器的 binlog 文件和位置：在主服务器上执行以下命令，获取当前的 binlog 文件名和位置，以便配置从服务器。</p></li>
</ol>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SHOW</span><span class="w"> </span><span class="n">MASTER</span><span class="w"> </span><span class="n">STATUS</span><span class="p">;</span>
</pre></div>
</div>
<p>结果会显示类似：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+------------------+----------+--------------+------------------+</span>
<span class="o">|</span> <span class="n">File</span>             <span class="o">|</span> <span class="n">Position</span> <span class="o">|</span> <span class="n">Binlog_Do_DB</span> <span class="o">|</span> <span class="n">Binlog_Ignore_DB</span> <span class="o">|</span>
<span class="o">+------------------+----------+--------------+------------------+</span>
<span class="o">|</span> <span class="n">mysql</span><span class="o">-</span><span class="nb">bin</span><span class="mf">.000001</span> <span class="o">|</span>  <span class="mi">154</span>     <span class="o">|</span> <span class="n">test</span>         <span class="o">|</span>                  <span class="o">|</span>
<span class="o">+------------------+----------+--------------+------------------+</span>
</pre></div>
</div>
<p>记录下 File（如 mysql-bin.000001）和 Position（如 154），稍后需要在从服务器配置时使用。</p>
<ol class="arabic simple" start="2">
<li><p>配置从服务器（Slave）</p></li>
</ol>
<ol class="arabic simple">
<li><p>配置从服务器：在从服务器的配置文件中设置一个唯一的 server-id，并配置主服务器的连接信息：</p></li>
</ol>
<p>[mysqld]
server-id=2            # 设置唯一的 server-id（从服务器的 id）
relay-log=slave-relay-log  # 设置中继日志文件名
log-bin=mysql-bin      # 启用 binlog
read-only=1            # 设置为只读模式，避免从服务器数据被修改</p>
<ol class="arabic simple" start="2">
<li><p>重启从服务器：</p></li>
</ol>
<p>sudo service mysql restart</p>
<ol class="arabic simple" start="3">
<li><p>配置主服务器连接信息：在从服务器上执行以下命令，配置主服务器的信息，包括 binlog 文件和位置：</p></li>
</ol>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="n">CHANGE</span><span class="w"> </span><span class="n">MASTER</span><span class="w"> </span><span class="k">TO</span>
<span class="n">MASTER_HOST</span><span class="o">=</span><span class="s1">&#39;master_ip&#39;</span><span class="p">,</span><span class="w">   </span><span class="c1">-- 主服务器的 IP 地址</span>
<span class="n">MASTER_USER</span><span class="o">=</span><span class="s1">&#39;replication_user&#39;</span><span class="p">,</span><span class="w">  </span><span class="c1">-- 上一步创建的用户</span>
<span class="n">MASTER_PASSWORD</span><span class="o">=</span><span class="s1">&#39;password&#39;</span><span class="p">,</span><span class="w">     </span><span class="c1">-- 密码</span>
<span class="n">MASTER_LOG_FILE</span><span class="o">=</span><span class="s1">&#39;mysql-bin.000001&#39;</span><span class="p">,</span><span class="w">  </span><span class="c1">-- 主服务器的 binlog 文件名</span>
<span class="n">MASTER_LOG_POS</span><span class="o">=</span><span class="mi">154</span><span class="p">;</span><span class="w">          </span><span class="c1">-- 主服务器的 binlog 位置</span>
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li><p>启动从服务器的复制进程：</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">START</span> <span class="n">SLAVE</span><span class="p">;</span>
</pre></div>
</div>
<ol class="arabic simple" start="5">
<li><p>检查从服务器的复制状态：</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SHOW</span> <span class="n">SLAVE</span> <span class="n">STATUS</span>\<span class="n">G</span>
</pre></div>
</div>
<p>如果复制正常，输出中 Slave_IO_Running 和 Slave_SQL_Running 都应该是 Yes。</p>
<p>监控与故障排查</p>
<ol class="arabic simple">
<li><p>查看主服务器的状态：</p></li>
</ol>
<p>SHOW MASTER STATUS;</p>
<ol class="arabic simple" start="2">
<li><p>查看从服务器的状态：</p></li>
</ol>
<p>SHOW SLAVE STATUS\G</p>
<ul class="simple">
<li><p>Slave_IO_Running：表示从服务器的 I/O 线程是否在运行。</p></li>
<li><p>Slave_SQL_Running：表示从服务器的 SQL 线程是否在运行。</p></li>
<li><p>Last_Error：如果从服务器出现问题，会记录错误信息。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>如果复制出现延迟或中断，可以尝试以下操作：</p></li>
</ol>
<ul class="simple">
<li><p>重新启动复制线程：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">STOP</span> <span class="n">SLAVE</span><span class="p">;</span>
<span class="n">START</span> <span class="n">SLAVE</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>检查复制延迟：查看主从服务器之间的延迟。</p></li>
<li><p>手动恢复同步：如果主从数据不同步，可以通过备份和恢复来修复数据不一致的问题，或使用 MASTER_POS_WAIT 等命令强制从服务器同步。</p></li>
</ul>
<p>主从同步的应用场景</p>
<ol class="arabic simple">
<li><p>负载均衡：可以将读操作分发到从服务器，从而减轻主服务器的负担。</p></li>
<li><p>数据备份：从服务器可以作为备份服务器，定期进行数据备份。</p></li>
<li><p>高可用性：主从复制可以实现数据库的容灾，如果主服务器故障，可以通过切换到从服务器来保持业务的连续性。</p></li>
</ol>
<p>总结</p>
<p>MySQL 的主从同步通过 binlog 和复制协议将主服务器的变更同步到从服务器。配置过程中，主服务器记录变更操作到 binlog，从服务器通过连接主服务器获取 binlog，并执行这些变更。同步的过程中，从服务器会定期拉取主服务器的变更记录，并保持同步状态。</p>
</section>
<section id="char-varchar">
<h2>11. char 和 varchar 有什么区别<a class="headerlink" href="#char-varchar" title="Link to this heading"></a></h2>
<p>CHAR 和 VARCHAR 都是用于存储字符串的 MySQL 数据类型，但它们在存储方式和使用场景上有所不同。下面是它们的主要区别：</p>
<ol class="arabic simple">
<li><p>存储方式</p></li>
</ol>
<ul class="simple">
<li><p>CHAR：</p></li>
<li><p>CHAR 是 固定长度 的字符串类型。如果存储的字符串长度小于定义的长度，MySQL 会自动用空格填充剩余的部分。例如，CHAR(10) 类型存储 “Hello” 会占用 10 个字符，其中后面 5 个字符为空格。</p></li>
<li><p>适用于长度固定的字符串（如国家代码、邮政编码等）。</p></li>
<li><p>VARCHAR：</p></li>
<li><p>VARCHAR 是 可变长度 的字符串类型。它只会存储实际字符长度，加上一个额外的字节来记录字符串的长度。</p></li>
<li><p>适用于长度变化较大的字符串（如用户的名字、电子邮件地址等）。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>存储空间</p></li>
</ol>
<ul class="simple">
<li><p>CHAR：</p></li>
<li><p>固定长度的字符串存储会浪费空间。例如，定义 CHAR(10) 存储 “Hello”，实际只用了 5 个字符，但会占用 10 个字符的空间。</p></li>
<li><p>VARCHAR：</p></li>
<li><p>只占用实际字符长度 + 1 或 2 字节的空间。1 字节用于存储字符串长度（当长度小于 255 字符时），2 字节用于存储长度（当长度大于 255 字符时）。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>性能</p></li>
</ol>
<ul class="simple">
<li><p>CHAR：</p></li>
<li><p>对于长度固定的字符串，CHAR 比 VARCHAR 更高效，因为它没有额外的字节用于存储长度信息。</p></li>
<li><p>当存储的字符串长度非常一致时，CHAR 可以提高查询性能，因为数据存储在固定位置，读取速度较快。</p></li>
<li><p>VARCHAR：</p></li>
<li><p>由于需要存储长度信息，VARCHAR 在存储空间和查询上稍微比 CHAR 慢，但如果存储的字符串长度变化较大，VARCHAR 会节省大量空间。</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>使用场景</p></li>
</ol>
<ul class="simple">
<li><p>CHAR：</p></li>
<li><p>适合存储长度固定的数据，如：国家代码、邮政编码、电话号码 等。</p></li>
<li><p>适合不经常更新的字段，或者字段长度总是固定的情况。</p></li>
<li><p>VARCHAR：</p></li>
<li><p>适合存储可变长度的字符串，如：用户名、电子邮件地址、文章标题 等。</p></li>
<li><p>当存储内容长度变化较大时，使用 VARCHAR 可以节省存储空间。</p></li>
</ul>
<ol class="arabic simple" start="5">
<li><p>空格处理</p></li>
</ol>
<ul class="simple">
<li><p>CHAR：</p></li>
<li><p>CHAR 会 自动填充空格，即使实际字符数小于定义的长度。</p></li>
<li><p>VARCHAR：</p></li>
<li><p>VARCHAR 不会填充空格，只存储实际的字符串内容。</p></li>
</ul>
<ol class="arabic simple" start="6">
<li><p>最大长度限制</p></li>
</ol>
<ul class="simple">
<li><p>CHAR：</p></li>
<li><p>最大长度为 255 字符。</p></li>
<li><p>VARCHAR：</p></li>
<li><p>最大长度为 65,535 字符（根据行大小和字符集的不同，可能稍有变化）。</p></li>
</ul>
<p>总结表格</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>特性</p></th>
<th class="head"><p>CHAR</p></th>
<th class="head"><p>VARCHAR</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>存储方式</p></td>
<td><p>固定长度</p></td>
<td><p>可变长度</p></td>
</tr>
<tr class="row-odd"><td><p>存储空间</p></td>
<td><p>固定大小，可能浪费空间</p></td>
<td><p>根据实际长度加上长度字节</p></td>
</tr>
<tr class="row-even"><td><p>性能</p></td>
<td><p>适合长度固定的字段，查询较快</p></td>
<td><p>适合长度可变的字段，但略微慢于 CHAR</p></td>
</tr>
<tr class="row-odd"><td><p>适用场景</p></td>
<td><p>长度固定的数据，如国家代码、邮政编码</p></td>
<td><p>长度可变的数据，如用户名、电子邮件地址</p></td>
</tr>
<tr class="row-even"><td><p>空格处理</p></td>
<td><p>自动填充空格</p></td>
<td><p>不填充空格</p></td>
</tr>
<tr class="row-odd"><td><p>最大长度</p></td>
<td><p>255 字符</p></td>
<td><p>65,535 字符（取决于行大小和字符集）</p></td>
</tr>
</tbody>
</table>
<p>何时使用 CHAR 或 VARCHAR？</p>
<ul class="simple">
<li><p>如果字段长度 固定，选择 CHAR 会更加高效。</p></li>
<li><p>如果字段长度 可变，选择 VARCHAR 可以节省空间并提高灵活性。</p></li>
</ul>
</section>
<section id="select">
<h2>12. select 语句会加锁吗?<a class="headerlink" href="#select" title="Link to this heading"></a></h2>
<p>在 MySQL 中，SELECT 语句是否会加锁，取决于查询的类型、使用的存储引擎、是否启用了锁机制等因素。下面是一些常见的情况：</p>
<ol class="arabic simple">
<li><p>默认情况下，SELECT 是否会加锁？</p></li>
</ol>
<ul class="simple">
<li><p>InnoDB 存储引擎：</p></li>
<li><p>普通 SELECT 查询：默认情况下，执行 SELECT 语句时，InnoDB 不会对读取的数据加锁。它会使用 共享锁（S Lock）来确保数据一致性，但不会阻塞其他 SELECT 查询。其他事务仍然可以读取相同的行数据，只要没有进行修改操作。</p></li>
<li><p>SELECT … FOR UPDATE：如果在 SELECT 语句中使用了 FOR UPDATE，InnoDB 会对选中的行加 排他锁（X Lock）。这个锁会阻塞其他事务对相同数据的访问，直到当前事务提交或回滚。</p></li>
<li><p>SELECT … LOCK IN SHARE MODE：如果使用了 LOCK IN SHARE MODE，InnoDB 会对选中的行加 共享锁（S Lock），允许其他事务读取这些行，但不允许其他事务更新这些行。</p></li>
<li><p>MyISAM 存储引擎：</p></li>
<li><p>SELECT 查询：MyISAM 存储引擎会对正在读取的表加 表级锁。即使是 SELECT 查询，在 MyISAM 中会对表加一个 共享锁，允许其他 SELECT 查询访问该表，但会阻塞任何写操作（如 INSERT、UPDATE 或 DELETE）。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>SELECT 查询会加哪些锁？</p></li>
</ol>
<ul class="simple">
<li><p>共享锁（S Lock）：</p></li>
<li><p>允许其他事务读取数据，但不允许修改。</p></li>
<li><p>在 InnoDB 中，SELECT 查询通常会自动加共享锁（例如，在事务中读取数据时，防止其他事务修改数据）。</p></li>
<li><p>排他锁（X Lock）：</p></li>
<li><p>在 SELECT … FOR UPDATE 中，InnoDB 会为选中的行加排他锁，阻止其他事务对这些行进行任何修改或读取（直到当前事务提交）。</p></li>
<li><p>表级锁：</p></li>
<li><p>在 MyISAM 存储引擎中，SELECT 查询会加表级锁，即对整个表进行共享锁定。其他 SELECT 查询仍然可以执行，但会阻塞任何对该表的修改操作。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>SELECT 查询的锁与事务的关系</p></li>
</ol>
<ul class="simple">
<li><p>事务中的 SELECT 查询：如果 SELECT 查询在事务中执行，它会根据事务的隔离级别和查询的方式决定是否加锁。例如，在 可重复读 隔离级别下，SELECT 查询可能会加锁，以确保读取到的数据在事务中保持一致。</p></li>
<li><p>隔离级别影响锁：</p></li>
<li><p>读已提交（Read Committed）：只会读取已提交的数据，不会加锁。</p></li>
<li><p>可重复读（Repeatable Read）：在读取数据时加共享锁，防止其他事务修改这些行。</p></li>
<li><p>串行化（Serializable）：会在 SELECT 查询时加锁，以避免其他事务修改或插入数据。</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>SELECT 查询不加锁的情况</p></li>
</ol>
<ul class="simple">
<li><p>无锁查询：如果是普通的 SELECT 查询（没有使用 FOR UPDATE 或 LOCK IN SHARE MODE），并且没有开启事务，MySQL 默认情况下不会加锁。</p></li>
<li><p>只读查询：在一些情况下，比如查询只读数据时，SELECT 语句不会加锁（或者加非常轻的锁，来确保数据的一致性）。</p></li>
</ul>
<ol class="arabic simple" start="5">
<li><p>总结</p></li>
</ol>
<ul class="simple">
<li><p>InnoDB：</p></li>
<li><p>默认的 SELECT 不会加锁，只会加 共享锁（不阻塞其他 SELECT）。</p></li>
<li><p>使用 SELECT … FOR UPDATE 时，会加 排他锁，阻塞其他事务对这些行的访问。</p></li>
<li><p>使用 SELECT … LOCK IN SHARE MODE 时，会加 共享锁，阻止其他事务更新数据。</p></li>
<li><p>MyISAM：</p></li>
<li><p>SELECT 会加 表级锁，阻塞写操作，但允许其他 SELECT 查询。</p></li>
</ul>
<p>在 MySQL 中，SELECT 查询的加锁行为主要受存储引擎、事务隔离级别和查询类型的影响。</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="mybatis_faq.html" class="btn btn-neutral float-left" title="MyBatic FAQ" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="quarkus_faq.html" class="btn btn-neutral float-right" title="Quarkus FAQ" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021 ~ 2035, Walter Fan, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>